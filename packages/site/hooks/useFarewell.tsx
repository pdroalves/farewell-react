"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import type { FhevmInstance } from "@/fhevm/fhevmTypes";
import { useFhevm } from "@/fhevm/useFhevm";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringInMemoryStorage } from "@/fhevm/GenericStringStorage";

// ⬇ generated by `npm run genabi`
import { FarewellABI } from "@/abi/FarewellABI";
import { FarewellAddresses } from "@/abi/FarewellAddresses";

/* -------------------------------------------------------------------------- */
/* Types & helpers                                                            */
/* -------------------------------------------------------------------------- */

type FarewellInfo = {
  abi: typeof FarewellABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

export type DeliveryPackage = {
  skShare: unknown;               // euint128 (opaque)
  encodedRecipientEmail: unknown; // euint256[] (opaque)
  emailByteLen: number;
  payload: `0x${string}`;
  publicMessage: string;
};

function getFarewellByChainId(chainId: number | undefined): FarewellInfo {
  if (!chainId) return { abi: FarewellABI.abi };
  const entry =
    FarewellAddresses[chainId.toString() as keyof typeof FarewellAddresses];
  if (!entry || entry.address === ethers.ZeroAddress) {
    return { abi: FarewellABI.abi, chainId };
  }
  return {
    address: entry.address as `0x${string}`,
    chainId: entry.chainId ?? chainId,
    chainName: entry.chainName,
    abi: FarewellABI.abi,
  };
}

function packEmailTo256Limbs(emailUtf8: string) {
  const bytes = new TextEncoder().encode(emailUtf8);
  const len = bytes.length;
  const limbs: bigint[] = [];
  for (let i = 0; i < bytes.length; i += 32) {
    const chunk = bytes.subarray(i, i + 32);
    let v = 0n;
    for (let j = 0; j < chunk.length; j++) v = (v << 8n) + BigInt(chunk[j]);
    limbs.push(v);
  }
  return { limbs, byteLen: len };
}

function hexlifyUtf8(s: string): `0x${string}` {
  return ethers.hexlify(ethers.toUtf8Bytes(s)) as `0x${string}`;
}

/* -------------------------------------------------------------------------- */
/* Hook                                                                        */
/* -------------------------------------------------------------------------- */

/**
 * Call with no args (auto-wiring) or pass objects explicitly (matches Zama’s pattern).
 */
export const useFarewell = (params?: {
  instance?: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage?: GenericStringInMemoryStorage;
  eip1193Provider?: ethers.Eip1193Provider | undefined;
  chainId?: number | undefined;
  ethersSigner?: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider?: ethers.ContractRunner | undefined;
  sameChain?: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner?: RefObject<(ethersSigner: ethers.JsonRpcSigner | undefined) => boolean>;
}) => {
  const p = params ?? {};

  // detect injected provider & chain id
  const eth =
    typeof window !== "undefined"
      ? ((window as any).ethereum as ethers.Eip1193Provider | undefined)
      : undefined;

  const [detectedChainId, setDetectedChainId] = useState<number | undefined>(
    p.chainId ?? (eth?.chainId ? parseInt(eth.chainId as string, 16) : undefined)
  );

  // ethers providers/signers (auto-wire if none passed)
  const [browserProvider, setBrowserProvider] = useState<
    ethers.BrowserProvider | undefined
  >(undefined);
  const [signer, setSigner] = useState<ethers.JsonRpcSigner | undefined>(
    p.ethersSigner
  );
  const [readonlyProvider, setReadonlyProvider] = useState<
    ethers.ContractRunner | undefined
  >(p.ethersReadonlyProvider);
  const [signerAddress, setSignerAddress] = useState<string | undefined>(
    (p.ethersSigner as any)?.address
  );

  const [isBusy, setIsBusy] = useState(false);
  const [message, setMessage] = useState("");

  // Build providers on mount / when ethereum changes
 // ⬇ REPLACE your two effects with this single effect
useEffect(() => {
  let cancelled = false;

  const eip1193 = p.eip1193Provider ?? eth;
  if (!eip1193) return;

  (async () => {
    try {
      const bp = new ethers.BrowserProvider(eip1193);
      if (cancelled) return;

      // Only set once to avoid retriggering
      setBrowserProvider((prev) => prev ?? bp);

      const net = await bp.getNetwork();
      if (cancelled) return;
      const cid = Number(net.chainId);

      // Set once (don’t flip-flop)
      setDetectedChainId((prev) => (prev === undefined ? cid : prev));

      // Signer
      const s = p.ethersSigner ?? (await bp.getSigner().catch(() => undefined));
      if (cancelled) return;
      setSigner(s);

      const addr =
        (s as any)?.address ??
        (s ? await s.getAddress().catch(() => undefined) : undefined);
      setSignerAddress(addr);

      // Readonly provider: set once
      if (!p.ethersReadonlyProvider) {
        const ro: ethers.ContractRunner =
          cid === 31337
            ? new ethers.JsonRpcProvider("http://127.0.0.1:8545")
            : bp;
        setReadonlyProvider((prev) => prev ?? ro);
      }
    } catch {
      /* ignore */
    }
  })();

  // Chain changed → clear signer; we’ll lazy-recreate on next use
  const onChainChanged = (newId: string) => {
    setDetectedChainId(parseInt(newId, 16));
    setSigner(undefined);
    setSignerAddress(undefined);
  };

  // Accounts changed → refresh signer/address only (DO NOT set browserProvider here)
  const onAccountsChanged = async (accounts: string[]) => {
    try {
      if (!accounts || accounts.length === 0) {
        setSigner(undefined);
        setSignerAddress(undefined);
        return;
      }
      const bp = new ethers.BrowserProvider(eip1193);
      const s = await bp.getSigner();
      const addr =
        (s as any)?.address ??
        (await s.getAddress().catch(() => undefined));
      setSigner(s);
      setSignerAddress(addr);
    } catch {
      /* ignore */
    }
  };

  (eip1193 as any)?.on?.("chainChanged", onChainChanged);
  (eip1193 as any)?.on?.("accountsChanged", onAccountsChanged);

  return () => {
    cancelled = true;
    (eip1193 as any)?.removeListener?.("chainChanged", onChainChanged);
    (eip1193 as any)?.removeListener?.("accountsChanged", onAccountsChanged);
  };
  // IMPORTANT: Do NOT depend on `browserProvider` here — keeps effect from looping
}, [eth, p.eip1193Provider, p.ethersSigner, p.ethersReadonlyProvider]);


  // local sameChain/sameSigner helpers, like Zama’s
  const chainIdRef = useRef<number | undefined>(detectedChainId);
  useEffect(() => { chainIdRef.current = detectedChainId; }, [detectedChainId]);

  const signerAddrRef = useRef<string | undefined>(signerAddress);
  useEffect(() => { signerAddrRef.current = signerAddress; }, [signerAddress]);

  const sameChainRef =
    p.sameChain ??
    useRef<(id: number | undefined) => boolean>((id) => id === chainIdRef.current);

  const sameSignerRef =
    p.sameSigner ??
    useRef<(s: ethers.JsonRpcSigner | undefined) => boolean>((s) => {
      const a = (s as any)?.address;
      const b = signerAddrRef.current;
      return a && b ? a.toLowerCase() === b.toLowerCase() : s === (signer as any);
    });

  // FHEVM instance (auto-create unless provided)
  const { instance } = useFhevm({
    provider: p.eip1193Provider ?? eth,
    chainId: detectedChainId,
    enabled: true,
    initialMockChains: { 31337: "http://127.0.0.1:8545" },
  });
  const fhevmInstance = p.instance ?? instance;
  const sigStore =
    p.fhevmDecryptionSignatureStorage ??
    new GenericStringInMemoryStorage("farewell:fhevm_decrypt_sig");

  // Farewell resolver
  const farewellRef = useRef<FarewellInfo | undefined>(undefined);
  const farewell = useMemo(() => {
    const c = getFarewellByChainId(detectedChainId);
    farewellRef.current = c;
    return c;
  }, [detectedChainId]);

  const isDeployed = useMemo(() => {
    if (!farewell) return undefined;
    return Boolean(farewell.address) && farewell.address !== ethers.ZeroAddress;
  }, [farewell]);

  const isConnected = !!signerAddress;

  // expose a connectWallet() like Zama demos do via UI
  const connectWallet = useCallback(async () => {
    const eip1193 = eth;
    if (!eip1193) throw new Error("No injected wallet (window.ethereum) found");
    await eip1193.request({ method: "eth_requestAccounts" });

    const bp = new ethers.BrowserProvider(eip1193);
    const s = await bp.getSigner();
    const addr =
      (s as any)?.address ?? (await s.getAddress().catch(() => undefined));

    setBrowserProvider(bp);
    setSigner(s);
    setSignerAddress(addr);

    // refresh network/readonly
    const net = await bp.getNetwork();
    const cid = Number(net.chainId);
    setDetectedChainId(cid);
    if (cid === 31337) {
      setReadonlyProvider(new ethers.JsonRpcProvider("http://127.0.0.1:8545"));
    } else {
      setReadonlyProvider(bp);
    }
  }, [eth]);

  const isBusyRef = useRef(isBusy);
  useEffect(() => { isBusyRef.current = isBusy; }, [isBusy]);

  /* ------------------------------------------------------------------------ */
  /* Reads                                                                    */
  /* ------------------------------------------------------------------------ */

  const messageCount = useCallback(
    async (owner: `0x${string}`) => {
      if (!farewell.address || !readonlyProvider) {
        throw new Error("Readonly provider or contract address not ready");
      }
      const contract = new ethers.Contract(
        farewell.address,
        farewell.abi,
        readonlyProvider
      );
      const n = (await contract.messageCount(owner)) as bigint;
      return n;
    },
    [farewell.address, farewell.abi, readonlyProvider]
  );

  const retrieve = useCallback(
    async (owner: `0x${string}`, index: bigint) => {
      if (!farewell.address || !readonlyProvider) {
        throw new Error("Readonly provider or contract address not ready");
      }
      const contract = new ethers.Contract(
        farewell.address,
        farewell.abi,
        readonlyProvider
      );
      const res = await contract.retrieve(owner, index);
      return {
        skShare: res[0],
        encodedRecipientEmail: res[1],
        emailByteLen: Number(res[2]),
        payload: res[3] as `0x${string}`,
        publicMessage: res[4] as string,
      } as DeliveryPackage;
    },
    [farewell.address, farewell.abi, readonlyProvider]
  );

  /* ------------------------------------------------------------------------ */
  /* Writes (register / ping)                                                 */
  /* ------------------------------------------------------------------------ */

  const register = useCallback(async () => {
    if (isBusyRef.current) return;
    if (!farewell.address || !signer) {
      throw new Error("Connect your wallet first.");
    }

    setIsBusy(true);
    setMessage("Start register()...");

    const thisChainId = detectedChainId;
    const thisFarewellAddress = farewell.address;
    const thisSigner = signer;

    const isStale = () =>
      thisFarewellAddress !== farewellRef.current?.address ||
      !sameChainRef.current(thisChainId) ||
      !sameSignerRef.current(thisSigner);

    try {
      const contract = new ethers.Contract(
        thisFarewellAddress,
        farewell.abi,
        thisSigner
      );
      const tx = await contract.register();
      setMessage(`Wait for tx: ${tx.hash}...`);
      await tx.wait();
      if (isStale()) return;
      setMessage("register() completed.");
    } catch (e: any) {
      setMessage(`register() failed: ${e?.message ?? e}`);
      throw e;
    } finally {
      setIsBusy(false);
    }
  }, [detectedChainId, farewell.address, farewell.abi, signer, sameChainRef, sameSignerRef]);

  const registerWithParams = useCallback(
    async (checkInSeconds: bigint, graceSeconds: bigint) => {
      if (isBusyRef.current) return;
      if (!farewell.address || !signer) {
        throw new Error("Connect your wallet first.");
      }

      setIsBusy(true);
      setMessage("Start register(checkIn,grace)...");

      const thisChainId = detectedChainId;
      const thisFarewellAddress = farewell.address;
      const thisSigner = signer;

      const isStale = () =>
        thisFarewellAddress !== farewellRef.current?.address ||
        !sameChainRef.current(thisChainId) ||
        !sameSignerRef.current(thisSigner);

      try {
        const contract = new ethers.Contract(
          thisFarewellAddress,
          farewell.abi,
          thisSigner
        );
        const tx = await contract.register(checkInSeconds, graceSeconds);
        setMessage(`Wait for tx: ${tx.hash}...`);
        await tx.wait();
        if (isStale()) return;
        setMessage("register(checkIn,grace) completed.");
      } catch (e: any) {
        setMessage(`register(checkIn,grace) failed: ${e?.message ?? e}`);
        throw e;
      } finally {
        setIsBusy(false);
      }
    },
    [detectedChainId, farewell.address, farewell.abi, signer, sameChainRef, sameSignerRef]
  );

  const ping = useCallback(async () => {
    if (isBusyRef.current) return;
    if (!farewell.address || !signer) {
      throw new Error("Connect your wallet first.");
    }

    setIsBusy(true);
    setMessage("Start ping()...");

    const thisChainId = detectedChainId;
    const thisFarewellAddress = farewell.address;
    const thisSigner = signer;

    const isStale = () =>
      thisFarewellAddress !== farewellRef.current?.address ||
      !sameChainRef.current(thisChainId) ||
      !sameSignerRef.current(thisSigner);

    try {
      const contract = new ethers.Contract(
        thisFarewellAddress,
        farewell.abi,
        thisSigner
      );
      const tx = await contract.ping();
      setMessage(`Wait for tx: ${tx.hash}...`);
      await tx.wait();
      if (isStale()) return;
      setMessage("ping() completed.");
    } catch (e: any) {
      setMessage(`ping() failed: ${e?.message ?? e}`);
      throw e;
    } finally {
      setIsBusy(false);
    }
  }, [detectedChainId, farewell.address, farewell.abi, signer, sameChainRef, sameSignerRef]);

  /* ------------------------------------------------------------------------ */
  /* Messages (addMessage / claim)                                            */
  /* ------------------------------------------------------------------------ */

  const addMessage = useCallback(
    async (
      emailUtf8: string,
      skShare: bigint,
      payload: string | `0x${string}`,
      publicMessage?: string
    ) => {
      if (isBusyRef.current) return;
      if (!farewell.address || !signer || !fhevmInstance) {
        throw new Error("Connect your wallet and ensure FHEVM is ready.");
      }

      const { limbs, byteLen } = packEmailTo256Limbs(emailUtf8);
      if (byteLen === 0) {
        setMessage("email len=0");
        throw new Error("email len=0");
      }

      setIsBusy(true);
      setMessage("Start addMessage... (encrypting)");

      const thisChainId = detectedChainId;
      const thisFarewellAddress = farewell.address;
      const thisSigner = signer;

      const isStale = () =>
        thisFarewellAddress !== farewellRef.current?.address ||
        !sameChainRef.current(thisChainId) ||
        !sameSignerRef.current(thisSigner);

      try {
        await new Promise((r) => setTimeout(r, 50)); // let UI breathe

        const userAddr =
          (thisSigner as any)?.address ??
          (await thisSigner.getAddress().catch(() => undefined));
        if (!userAddr) throw new Error("Cannot resolve signer address");

        const input = fhevmInstance.createEncryptedInput(
          thisFarewellAddress,
          userAddr as `0x${string}`
        );
        for (const v of limbs) input.add256(v);
        input.add128(skShare);

        const enc = await input.encrypt();
        if (isStale()) {
          setMessage("Ignore addMessage (stale)");
          setIsBusy(false);
          return;
        }

        const limbHandles = enc.handles.slice(0, limbs.length);
        const encSkShareHandle = enc.handles[limbs.length];
        const inputProof = enc.inputProof;
        const payloadHex =
          typeof payload === "string" && !payload.startsWith("0x")
            ? hexlifyUtf8(payload)
            : (payload as `0x${string}`);

        const contract = new ethers.Contract(
          thisFarewellAddress,
          farewell.abi,
          thisSigner
        );

        setMessage("Sending addMessage tx...");

        const tx = await (publicMessage !== undefined
          ? contract.addMessage(
              limbHandles,
              byteLen,
              encSkShareHandle,
              payloadHex,
              inputProof,
              publicMessage
            )
          : contract.addMessage(
              limbHandles,
              byteLen,
              encSkShareHandle,
              payloadHex,
              inputProof
            ));

        setMessage(`Wait for tx: ${tx.hash}...`);
        const receipt = await tx.wait();
        setMessage(`addMessage completed status=${receipt?.status}`);
      } catch (e: any) {
        setMessage(`addMessage failed: ${e?.message ?? e}`);
        throw e;
      } finally {
        setIsBusy(false);
      }
    },
    [detectedChainId, farewell.address, farewell.abi, signer, fhevmInstance, sameChainRef, sameSignerRef]
  );

  const claim = useCallback(
    async (owner: `0x${string}`, index: bigint) => {
      if (isBusyRef.current) return;
      if (!farewell.address || !signer) {
        throw new Error("Connect your wallet first.");
      }

      setIsBusy(true);
      setMessage("Start claim()...");

      const thisChainId = detectedChainId;
      const thisFarewellAddress = farewell.address;
      const thisSigner = signer;

      const isStale = () =>
        thisFarewellAddress !== farewellRef.current?.address ||
        !sameChainRef.current(thisChainId) ||
        !sameSignerRef.current(thisSigner);

      try {
        const contract = new ethers.Contract(
          thisFarewellAddress,
          farewell.abi,
          thisSigner
        );
        const tx = await contract.claim(owner, index);
        setMessage(`Wait for tx: ${tx.hash}...`);
        await tx.wait();
        if (isStale()) return;
        setMessage("claim() completed.");
      } catch (e: any) {
        setMessage(`claim() failed: ${e?.message ?? e}`);
        throw e;
      } finally {
        setIsBusy(false);
      }
    },
    [detectedChainId, farewell.address, farewell.abi, signer, sameChainRef, sameSignerRef]
  );

  /* ------------------------------------------------------------------------ */
  /* Optional decrypt sample (not wired to UI)                                 */
  /* ------------------------------------------------------------------------ */

  const decryptSkShare = useCallback(
    async (skShareHandle: string | undefined) => {
      if (!skShareHandle) return;
      if (!farewell.address || !fhevmInstance || !signer) return;

      const thisChainId = detectedChainId;
      const thisFarewellAddress = farewell.address;
      const thisSigner = signer;

      const isStale = () =>
        thisFarewellAddress !== farewellRef.current?.address ||
        !sameChainRef.current(thisChainId) ||
        !sameSignerRef.current(thisSigner);

      try {
        const sig = await FhevmDecryptionSignature.loadOrSign(
          fhevmInstance,
          [thisFarewellAddress],
          thisSigner,
          sigStore
        );
        if (!sig || isStale()) return;

        setMessage("Call FHEVM userDecrypt...");
        await fhevmInstance.userDecrypt(
          [{ handle: skShareHandle, contractAddress: thisFarewellAddress }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );
      } catch (e: any) {
        setMessage(`userDecrypt failed: ${e?.message ?? e}`);
      }
    },
    [detectedChainId, farewell.address, fhevmInstance, signer, sigStore, sameChainRef, sameSignerRef]
  );

  return {
    // deployment/meta
    contractAddress: farewell.address,
    chainId: detectedChainId,
    isDeployed,

    // wallet status
    isConnected,
    accountAddress: signerAddress,
    connectWallet,

    // UX
    message,
    isBusy,

    // lifecycle
    register,
    registerWithParams,
    ping,

    // messages
    addMessage,
    claim,

    // reads
    messageCount,
    retrieve,

    // optional decrypt sample
    decryptSkShare,
  };
};
