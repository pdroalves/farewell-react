"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import type { FhevmInstance } from "@/fhevm/fhevmTypes";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  Auto-generated by your genabi script:
  - @/abi/FarewellABI.ts
  - @/abi/FarewellAddresses.ts
*/
import { FarewellABI } from "@/abi/FarewellABI";
import { FarewellAddresses } from "@/abi/FarewellAddresses";

export type DeliveryPackage = {
  skShare: unknown; // euint128 (opaque)
  encodedRecipientEmail: unknown; // euint256[] (opaque)
  emailByteLen: number;
  payload: `0x${string}`;
  publicMessage: string;
};

type FarewellInfoType = {
  abi: typeof FarewellABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

function getFarewellByChainId(chainId: number | undefined): FarewellInfoType {
  if (!chainId) return { abi: FarewellABI.abi };

  const entry =
    FarewellAddresses[chainId.toString() as keyof typeof FarewellAddresses];

  if (!entry || entry.address === ethers.ZeroAddress) {
    return { abi: FarewellABI.abi, chainId };
  }

  return {
    address: entry.address as `0x${string}`,
    chainId: entry.chainId ?? chainId,
    chainName: entry.chainName,
    abi: FarewellABI.abi,
  };
}

/** Pack UTF-8 into big-endian 32-byte limbs for euint256[] */
function packEmailTo256Limbs(emailUtf8: string) {
  const bytes = new TextEncoder().encode(emailUtf8);
  const len = bytes.length;
  const limbs: bigint[] = [];
  for (let i = 0; i < bytes.length; i += 32) {
    const chunk = bytes.subarray(i, i + 32);
    let v = BigInt(0);
    for (let j = 0; j < chunk.length; j++)
      v = (v << BigInt(8)) + BigInt(chunk[j]);
    limbs.push(v);
  }
  return { limbs, byteLen: len };
}

export const useFarewell = (parameters: {
  instance: FhevmInstance | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  // UI-ish states mirrored from demo
  const [message, setMessage] = useState<string>("");
  const [isBusy, setIsBusy] = useState<boolean>(false);
  const isBusyRef = useRef(isBusy);

  useEffect(() => {
    isBusyRef.current = isBusy;
  }, [isBusy]);

  const [isRegistered, setIsRegistered] = useState<boolean | undefined>(
    undefined
  );

  const farewellRef = useRef<FarewellInfoType | undefined>(undefined);
  const farewell = useMemo(() => {
    const c = getFarewellByChainId(chainId);
    farewellRef.current = c;
    if (!c.address) {
      setMessage(`Farewell deployment not found for chainId=${chainId}.`);
    }
    return c;
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!farewell) return undefined;
    return Boolean(farewell.address) && farewell.address !== ethers.ZeroAddress;
  }, [farewell]);

  /* ───────────────────────────────── READS ───────────────────────────────── */

  const checkRegistration = useCallback(async () => {
    if (!farewell.address || !ethersReadonlyProvider) {
      throw new Error("Readonly provider or contract address not ready");
    }
    setIsBusy(true);
    try {
      if (!ethersSigner) {
        throw new Error("Connect your wallet");
      }
      const addr = (await ethersSigner.getAddress()) as `0x${string}`;

      const contract = new ethers.Contract(
        farewell.address,
        farewell.abi,
        ethersReadonlyProvider
      );

      if (!contract || !addr) {
        // If we can’t check, show no status (or false—your call)
        setIsRegistered(undefined);
        return undefined;
      }
      // Show "checking…" while the call is in flight
      setIsRegistered(undefined);
      const res: boolean = await contract.isRegistered(addr);
      setIsRegistered(res);
      return res;
    } catch (err) {
      console.error("isRegistered check failed:", err);
      // Decide what you want in error: false or undefined.
      // Using false prevents the UI from being stuck.
      setIsRegistered(false);
      return false;
    } finally {
      setIsBusy(false);
    }
  }, [farewell.address, farewell.abi, ethersReadonlyProvider]);

  // Auto-check whenever we have a contract + user
  useEffect(() => {
    let cancelled = false;
    (async () => {
      if (!farewell.address || !ethersReadonlyProvider) {
        console.log("Readonly provider or contract address not ready");
      }
      try {
        if (!ethersSigner) {
          throw new Error("Connect your wallet");
        }
        const addr = (await ethersSigner.getAddress()) as `0x${string}`;

        const checkContract = farewell.address ? farewell.address : "";
        const contract = new ethers.Contract(
          checkContract,
          farewell.abi,
          ethersReadonlyProvider
        );

        if (!contract || !addr) {
          setIsRegistered(undefined);
          return;
        }
        setIsRegistered(undefined); // triggers "(checking…)"
        const res: boolean = await contract.isRegistered(addr);
        if (!cancelled) setIsRegistered(res);
      } catch {
        if (!cancelled) setIsRegistered(false);
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [farewell.address, farewell.abi, ethersReadonlyProvider]);

  const messageCount = useCallback(
    async (owner?: `0x${string}`) => {
      if (!farewell.address || !ethersReadonlyProvider) {
        throw new Error("Readonly provider or contract address not ready");
      }
      setIsBusy(true);
      try {
        // Default to the connected signer’s address if no owner was passed
        let target: `0x${string}` | undefined = owner;
        if (!target) {
          if (!ethersSigner) {
            throw new Error("Pass an owner address or connect your wallet");
          }
          const addr = (await ethersSigner.getAddress()) as `0x${string}`;
          target = addr;
        }

        setMessage(`Querying for number of messages for ${target}...`);

        const contract = new ethers.Contract(
          farewell.address,
          farewell.abi,
          ethersReadonlyProvider
        );

        const result = (await contract.messageCount(target)) as bigint;
        setMessage(``);
        return result;
      } finally {
        setIsBusy(false);
      }
    },
    [farewell.address, farewell.abi, ethersReadonlyProvider]
  );

  const retrieve = useCallback(
    async (owner: `0x${string}`, index: bigint) => {
      if (!farewell.address) throw new Error("Contract address not ready");

      setIsBusy(true);
      try {
        // Determine target owner and current caller
        const target = owner ?? (await ethersSigner?.getAddress());
        if (!target)
          throw new Error("Pass an owner address or connect your wallet");

        // If we have a signer and it matches the owner, call via signer
        if (
          ethersSigner &&
          (await ethersSigner.getAddress()).toLowerCase() ===
            target.toLowerCase()
        ) {
          console.log("owner is the signer");

          const contract = new ethers.Contract(
            farewell.address,
            farewell.abi,
            ethersSigner
          );
          const res = await contract.retrieve(target, index);
          setIsBusy(false);
          return {
            skShare: res[0],
            encodedRecipientEmail: res[1],
            emailByteLen: Number(res[2]),
            payload: res[3] as `0x${string}`,
            publicMessage: res[4] as string,
          } as DeliveryPackage;
        } else {
          console.log("owner is NOT the signer");
          // Otherwise, use readonly provider but set the "from" override so msg.sender == target
          if (!ethersReadonlyProvider)
            throw new Error("Readonly provider not ready");
          const contract = new ethers.Contract(
            farewell.address,
            farewell.abi,
            ethersReadonlyProvider
          );
          // Ethers v5:
          const res = await contract.retrieve(target, index, {
            from: target,
          });
          // If you're on Ethers v6, use: await contractRO.retrieve.staticCall(target, index, { from: target });

          setIsBusy(false);
          return {
            skShare: res[0],
            encodedRecipientEmail: res[1],
            emailByteLen: Number(res[2]),
            payload: res[3] as `0x${string}`,
            publicMessage: res[4] as string,
          } as DeliveryPackage;
        }
      } finally {
        setIsBusy(false);
      }
    },
    [farewell.address, farewell.abi, ethersReadonlyProvider, ethersSigner]
  );

  /* ──────────────────────────────── WRITES ──────────────────────────────── */

  const register = useCallback(async () => {
    if (isBusyRef.current) return;
    if (!farewell.address || !ethersSigner) return;

    const thisChainId = chainId;
    const thisAddr = farewell.address;
    const thisSigner = ethersSigner;

    const isStale = () =>
      thisAddr !== farewellRef.current?.address ||
      !sameChain.current(thisChainId) ||
      !sameSigner.current(thisSigner);

    setIsBusy(true);
    setMessage("Start register()...");

    try {
      const c = new ethers.Contract(thisAddr, farewell.abi, thisSigner);

        const reg = c.getFunction("register()");
        const tx = await reg();
      setMessage(`Wait for tx: ${tx.hash}...`);
      await tx.wait();
      await checkRegistration();
      if (isStale()) return;
      setMessage("register() completed.");
    } catch (e: unknown) {
      const raw =
        e instanceof Error
          ? e?.message
          : typeof e === "string"
            ? e
            : JSON.stringify(e);
      setMessage(`register() failed: ${raw}`);
    } finally {
      setIsBusy(false);
    }
  }, [
    farewell.address,
    farewell.abi,
    ethersSigner,
    chainId,
    sameChain,
    sameSigner,
    checkRegistration,
  ]);

  const registerWithParams = useCallback(
    async (checkInSeconds: bigint, graceSeconds: bigint) => {
      if (isBusyRef.current) return;
      if (!farewell.address || !ethersSigner) return;

      const thisChainId = chainId;
      const thisAddr = farewell.address;
      const thisSigner = ethersSigner;

      const isStale = () =>
        thisAddr !== farewellRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisSigner);

      setIsBusy(true);
      setMessage("Start register(checkIn,grace)...");

      try {
        const c = new ethers.Contract(thisAddr, farewell.abi, thisSigner);
        const reg = c.getFunction("register(uint64,uint64)");
        const tx = await reg(checkInSeconds, graceSeconds);
        setMessage(`Wait for tx: ${tx.hash}...`);
        await tx.wait();
        await checkRegistration();
        if (isStale()) return;
        setMessage("register(checkIn,grace) completed.");
      } catch (e: unknown) {
        const raw =
          e instanceof Error
            ? e?.message
            : typeof e === "string"
              ? e
              : JSON.stringify(e);
        setMessage(`register(checkIn,grace) failed: ${raw}`);
      } finally {
        setIsBusy(false);
      }
    },
    [
      chainId,
      farewell.address,
      farewell.abi,
      ethersSigner,
      sameChain,
      sameSigner,
    ]
  );

  const ping = useCallback(async () => {
    if (isBusyRef.current) return;
    if (!farewell.address || !ethersSigner) return;

    const thisChainId = chainId;
    const thisAddr = farewell.address;
    const thisSigner = ethersSigner;

    const isStale = () =>
      thisAddr !== farewellRef.current?.address ||
      !sameChain.current(thisChainId) ||
      !sameSigner.current(thisSigner);

    setIsBusy(true);
    setMessage("Start ping()...");

    try {
      const c = new ethers.Contract(thisAddr, farewell.abi, thisSigner);
      const tx = await c.ping();
      setMessage(`Wait for tx: ${tx.hash}...`);
      await tx.wait();
      if (isStale()) return;
      setMessage("ping() completed.");
    } catch (e: unknown) {
      const raw =
        e instanceof Error
          ? e.message
          : typeof e === "string"
            ? e
            : JSON.stringify(e);
      setMessage(`ping() failed: ${raw}`);
    } finally {
      setIsBusy(false);
    }
  }, [
    chainId,
    farewell.address,
    farewell.abi,
    ethersSigner,
    sameChain,
    sameSigner,
  ]);

  const addMessage = useCallback(
    async (
      emailUtf8: string,
      skShare: bigint,
      payload: string | `0x${string}`,
      publicMessage?: string
    ): Promise<{ txHash: string; receipt: ethers.TransactionReceipt }> => {
      if (isBusyRef.current) throw new Error("Busy");

      if (!farewell.address) {
        throw new Error(
          `Contract address unavailable for chainId=${chainId}. Check packages/site/abi/FarewellAddresses.ts and re-run "npm run genabi".`
        );
      }
      if (!ethersSigner) {
        throw new Error("Connect your wallet first (no signer).");
      }
      if (!instance) {
        throw new Error("FHEVM instance not ready yet (status !== ready).");
      }

      const thisChainId = chainId;
      const thisAddr = farewell.address;
      const thisSigner = ethersSigner;

      const isStale = () =>
        thisAddr !== farewellRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisSigner);

      const { limbs, byteLen } = packEmailTo256Limbs(emailUtf8);
      if (byteLen === 0) throw new Error("email len=0");

      setIsBusy(true);
      setMessage("Start addMessage... (encrypting)");

      try {
        // Let UI breathe before WASM-heavy encrypt
        await new Promise((r) => setTimeout(r, 80));

        const userAddr =
          thisSigner.address ??
          (await thisSigner.getAddress().catch(() => undefined));
        if (!userAddr) throw new Error("Cannot resolve signer address");

        const input = instance.createEncryptedInput(
          thisAddr,
          userAddr as `0x${string}`
        );
        for (const v of limbs) input.add256(v);
        input.add128(skShare);

        const enc = await input.encrypt();

        if (isStale()) {
          setMessage("Ignore addMessage (stale context)");
          throw new Error("stale context");
        }

        const limbHandles = enc.handles.slice(0, limbs.length);
        const encSkShareHandle = enc.handles[limbs.length];
        const inputProof = enc.inputProof;

        const payloadHex =
          typeof payload === "string" && !payload.startsWith("0x")
            ? (ethers.hexlify(ethers.toUtf8Bytes(payload)) as `0x${string}`)
            : (payload as `0x${string}`);

        const c = new ethers.Contract(thisAddr, farewell.abi, thisSigner);

        // Disambiguate overloads (ethers v6)
        const addMsg = c.getFunction(
          "addMessage(bytes32[],uint32,bytes32,bytes,bytes)"
        );
        const addMsgWithPublicPart = c.getFunction(
          "addMessage(bytes32[],uint32,bytes32,bytes,bytes,string)"
        );

        setMessage("Sending addMessage tx...");

        const tx: ethers.TransactionResponse =
          publicMessage !== undefined
            ? await addMsgWithPublicPart(
                limbHandles,
                byteLen,
                encSkShareHandle,
                payloadHex,
                inputProof,
                publicMessage
              )
            : await addMsg(
                limbHandles,
                byteLen,
                encSkShareHandle,
                payloadHex,
                inputProof
              );

        const txHash = tx.hash;
        setMessage(
          `Tx sent: ${txHash}${
            thisChainId === 11155111
              ? " (view on Etherscan: https://sepolia.etherscan.io/tx/" +
                txHash +
                ")"
              : ""
          } — waiting for confirmation...`
        );

        const receipt = await tx.wait();

        if (isStale()) throw new Error("stale context (post-mining)");

        if (!receipt || receipt.status !== 1) {
          setMessage(
            `addMessage mined with failure status=${receipt?.status ?? "?"}`
          );
          throw new Error("Transaction failed");
        }

        setMessage(
          `addMessage confirmed in block ${receipt.blockNumber}. View on Etherscan: https://sepolia.etherscan.io/tx/${txHash})`
        );
        return { txHash, receipt };
      } catch (e: unknown) {
        const raw =
          e instanceof Error
            ? e.message
            : typeof e === "string"
              ? e
              : JSON.stringify(e);
        setMessage(`addMessage failed: ${raw}`);
        throw e;
      } finally {
        setIsBusy(false);
      }
    },
    [
      chainId,
      farewell.address,
      farewell.abi,
      ethersSigner,
      instance,
      sameChain,
      sameSigner,
    ]
  );

  const markDeceased = useCallback(
    async (target?: `0x${string}`) => {
      if (!farewell.address || !ethersReadonlyProvider) {
        throw new Error("Readonly provider or contract address not ready");
      }

      const thisChainId = chainId;
      const thisAddr = farewell.address;
      const thisSigner = ethersSigner;
      const isStale = () =>
        thisAddr !== farewellRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisSigner);

      setIsBusy(true);
      const contract = new ethers.Contract(thisAddr, farewell.abi, thisSigner);
      try {
        const tx = await contract.markDeceased(target);
        setMessage(`Trying to mark ${target} as deceased...`);
        await tx.wait();
        if (isStale()) return;
      } catch (e: unknown) {
        const raw =
          e instanceof Error
            ? e.message
            : typeof e === "string"
              ? e
              : JSON.stringify(e);
        setMessage(`markDeceased() failed: ${raw}`);
      } finally {
        setIsBusy(false);
      }
    },
    [farewell.address, farewell.abi, ethersReadonlyProvider]
  );

  const claim = useCallback(
    async (owner: `0x${string}`, index: bigint) => {
      if (isBusyRef.current) return;
      if (!farewell.address || !ethersSigner) return;

      const thisChainId = chainId;
      const thisAddr = farewell.address;
      const thisSigner = ethersSigner;

      const isStale = () =>
        thisAddr !== farewellRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisSigner);

      setIsBusy(true);
      setMessage("Start claim()...");

      try {
        const c = new ethers.Contract(thisAddr, farewell.abi, thisSigner);
        const tx = await c.claim(owner, index);
        setMessage(`Wait for tx: ${tx.hash}...`);
        await tx.wait();
        if (isStale()) return;
        setMessage("claim() completed.");
      } catch (e: unknown) {
        const raw =
          e instanceof Error
            ? e.message
            : typeof e === "string"
              ? e
              : JSON.stringify(e);
        setMessage(`claim() failed: ${raw}`);
      } finally {
        setIsBusy(false);
      }
    },
    [
      chainId,
      farewell.address,
      farewell.abi,
      ethersSigner,
      sameChain,
      sameSigner,
    ]
  );

  return {
    contractAddress: farewell.address,
    isDeployed,
    // UX
    message,
    isBusy,
    // lifecycle
    register,
    registerWithParams,
    ping,
    markDeceased,
    // messages
    addMessage,
    claim,
    // reads
    messageCount,
    retrieve,
    isRegistered,
    checkRegistration,
  };
};
