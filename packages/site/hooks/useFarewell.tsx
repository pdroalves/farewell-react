"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at 
  <root>/scripts/genabi.mjs. This script parses the 
  <root>/packages/farewell/deployments directory to retrieve 
  deployment information for Farewell.sol:
  
  - <root>/packages/site/abi/abi/FarewellABI.ts
  - <root>/packages/site/abi/abi/FarewellAddresses.ts
*/
import { FarewellAddresses } from "@/abi/FarewellAddresses";
import { FarewellABI } from "@/abi/FarewellABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};
type FarewellInfoType = {
  abi: typeof FarewellABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves Farewell contract metadata for the given EVM `chainId`.
 *
 * The ABI and address book are **generated** from the `fhevm-hardhat-template`
 * artifacts into the `@/abi` folder at build time. This function performs a
 * simple lookup in that generated map.
 *
 * Behavior:
 * - If `chainId` is `undefined` or not found in the map, returns ABI only.
 * - Otherwise returns `{ abi, address, chainId, chainName }`.
 *
 * @param chainId - Target chain id (e.g., 1, 5, 11155111). `undefined` returns ABI-only.
 * @returns Contract info for `the chain or ABI-only fallback.
 * @example
 * const { abi, address } = getFarewellByChainId(chainId);
 */
function getFarewellByChainId(
  chainId: number | undefined
): FarewellInfoType {
    console.log("chainId1", chainId);
  if (!chainId) {
    return { abi: FarewellABI.abi };
  }

  const entry =
    FarewellAddresses[chainId.toString() as keyof typeof FarewellAddresses];
    console.log("chainId2", chainId);
    
  //   if (!("address" in entry) || entry.address === ethers.ZeroAddress) {
  //     return { abi: FarewellABI.abi, chainId };
  // }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: FarewellABI.abi,
  };
}

/*
 * Main Farewell React component with 1 button
 *  - "register" button: do register
 */
export const useFarewell = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const farewellRef = useRef<FarewellInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isDecryptingRef = useRef<boolean>(isDecrypting);

  //////////////////////////////////////////////////////////////////////////////
  // Farewell
  //////////////////////////////////////////////////////////////////////////////

  console.log("chainId", chainId);
    const farewell = useMemo(() => {
      const c = getFarewellByChainId(chainId);

      farewellRef.current = c;

      if (!c.address) {
        setMessage(`Farewell deployment not found for chainId=${chainId}.`);
      }

      return c;
    }, [chainId]);

    const isDeployed = useMemo(() => {
    if (!farewell) {
      return undefined;
    }
    return (Boolean(farewell.address) && farewell.address !== ethers.ZeroAddress);
  }, [farewell]);

    const canDecrypt = useMemo(() => {
    return (
      farewell.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecrypting
    );
  }, [
    farewell.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecrypting,
  ]);

  console.log("isDeployed", isDeployed);

  return {
    contractAddress: farewell.address,
    canDecrypt,
    message,
    isDecrypting,
    isRefreshing,
    isDeployed
  };
}